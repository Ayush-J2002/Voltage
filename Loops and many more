# replacement_steps_upload.py
import pyvisa
import time

TARGET_RESOURCE = "USB0::0x0B3E::0x1012::EZ002642::INSTR"
PROGRAM_SLOT    = "1"
PROGRAM_TITLE   = "ACC_D1_TEST"
LOOP_COUNT      = 1
CURRENT_LIMIT_A = 5.0

PATTERN_TO_UPLOAD = [
    {"step": 1, "volt": 0.0,  "time": 1.0},
    {"step": 2, "volt": 12.0, "time": 0.1},
    {"step": 3, "volt": 0.0,  "time": 1.0},
    {"step": 4, "volt": 13.0, "time": 20.0},
    {"step": 5, "volt": 0.0,  "time": 2.0},
]

def query_err(inst, ctx=""):
    """Query instrument error register and raise on error text."""
    try:
        e = inst.query("SYST:ERR?").strip()
    except Exception:
        raise RuntimeError(f"{ctx}: failed to query SYST:ERR?")
    # many instruments return "0,No error" or similar; treat any non "No error" as problem
    if e and ("no error" not in e.lower() and not e.startswith("0,")):
        raise RuntimeError(f"SCPI error after {ctx}: {e}")
    return e

def select_program(inst, slot):
    inst.write("*CLS")
    inst.write("ABORT")
    inst.write("SYST:REM")
    time.sleep(0.1)
    inst.write(f':PROG:NAME "{slot}"')   # select/create program slot
    query_err(inst, "select_program")

def set_program_header(inst, title, loops):
    inst.write(f':PROG:EDIT:TITL "{title}"')
    inst.write(f":PROG:EDIT:LOOP {int(loops)}")
    query_err(inst, "set_program_header")

def clear_program_steps(inst):
    """Delete all steps in the selected program (optional, safe start)."""
    inst.write(":PROG:EDIT:DEL")   # deletes all steps for selected program
    query_err(inst, "clear_program_steps")

def write_step_fields(inst, step_idx, volt, curr_limit, dwell_s):
    """
    Create / select the step index, then set its VOLT, CURR and TIME fields.
    The manual shows selecting a step with PROG:EDIT:STEP:SEL and setting fields with
    PROG:EDIT:STEP:VOLT / :CURR / :TIME.
    """
    inst.write(f"PROG:EDIT:STEP:SEL {int(step_idx)}")
    query_err(inst, f"select step {step_idx}")

    # Set DC voltage for selected step
    inst.write(f"PROG:EDIT:STEP:VOLT {float(volt)}")
    query_err(inst, f"VOLT step {step_idx}")

    # Set current (I limit) for selected step
    inst.write(f"PROG:EDIT:STEP:CURR {float(curr_limit)}")
    query_err(inst, f"CURR step {step_idx}")

    # Set the dwell / execution time for the selected step
    inst.write(f"PROG:EDIT:STEP:TIME {float(dwell_s)}")
    query_err(inst, f"TIME step {step_idx}")

    # optionally: ensure output state for that step (ON=1 or OFF=0) and triggers (example: ON,OFF,OFF)
    # inst.write(f"PROG:EDIT:STEP:STAT 1,0,0")
    # query_err(inst, f"STAT step {step_idx}")

def save_program(inst):
    inst.write(":PROG:SAVE")
    time.sleep(0.3)
    query_err(inst, "save_program")

def run_program(inst):
    inst.write("OUTP 1")
    time.sleep(0.1)
    inst.write(":PROG:EXEC:STAT RUN")
    query_err(inst, "run_program")

def upload_and_run_sequence(resource_str, slot, title, loops, current_limit, steps_list, run=True):
    rm = pyvisa.ResourceManager()
    inst = rm.open_resource(resource_str)
    inst.read_termination = "\n"
    inst.write_termination = "\n"
    inst.timeout = 5000

    try:
        print("IDN:", inst.query("*IDN?").strip())
        select_program(inst, slot)
        set_program_header(inst, title, loops)

        # wipe existing steps to avoid leftovers (optional)
        clear_program_steps(inst)

        # write each step: select then set fields
        for s in sorted(steps_list, key=lambda x: x["step"]):
            print(f"Writing step {s['step']}: V={s['volt']}V, T={s['time']}s")
            write_step_fields(inst, s["step"], s["volt"], current_limit, s["time"])

        save_program(inst)
        print("Program saved.")

        if run:
            run_program(inst)
            print("Program started.")
    finally:
        inst.close()
        print("Connection closed.")

if __name__ == "__main__":
    upload_and_run_sequence(
        TARGET_RESOURCE,
        PROGRAM_SLOT,
        PROGRAM_TITLE,
        LOOP_COUNT,
        CURRENT_LIMIT_A,
        PATTERN_TO_UPLOAD,
        run=True
    )
