import pyvisa
import time

# ========= USER SETTINGS =========

TARGET_RESOURCE = "USB0::0x0B3E::0x1012::EZ002642::INSTR"   # your VISA address
PROGRAM_SLOT    = "1"                                      # "1" .. "16"
PROGRAM_TITLE   = "ACC_D1_TEST"
CURRENT_LIMIT_A = 5.0                                      # safe under 6 A OCP

# Sequence you want in the program
# step numbers should be 1..N
STEPS = [
    {"step": 1, "volt": 0.0,  "time": 1.0},   # 0 V  for 1 s
    {"step": 2, "volt": 12.0, "time": 0.1},   # 12 V for 0.1 s
    {"step": 3, "volt": 0.0,  "time": 1.0},   # 0 V  for 1 s
    {"step": 4, "volt": 13.0, "time": 20.0},  # 13 V for 20 s
    {"step": 5, "volt": 0.0,  "time": 2.0},   # 0 V  for 2 s
]

# ========= HELPERS =========

def write_and_report(inst, cmd):
    """Send a SCPI command and print SYST:ERR?"""
    inst.write(cmd)
    time.sleep(0.03)
    err = inst.query("SYST:ERR?")
    print(f"WROTE '{cmd}' -> {err.strip()}")
    return err

def main():
    rm = pyvisa.ResourceManager()
    inst = rm.open_resource(TARGET_RESOURCE)
    inst.write_termination = "\n"
    inst.read_termination  = "\n"
    inst.timeout = 5000

    try:
        print("IDN:", inst.query("*IDN?").strip())

        # --- Go to remote, clear errors (no full reset so we don't break your setup memory) ---
        inst.write("*CLS")
        inst.write("SYST:REM")
        time.sleep(0.1)
        print("SYST:ERR? ->", inst.query("SYST:ERR?").strip())

        # --- Select program slot and set title ---
        print("\n--- Selecting program and setting title ---")
        write_and_report(inst, f'PROG:NAME "{PROGRAM_SLOT}"')
        write_and_report(inst, f'PROG:EDIT:TITL "{PROGRAM_TITLE}"')

        # --- Set global mode/limits (optional, but usually what you want) ---
        # CV mode & current limit
        write_and_report(inst, "FUNC VOLT")                     # CV mode
        write_and_report(inst, f"CURR {CURRENT_LIMIT_A}")       # current limit

        # --- Delete all existing steps ---
        print("\n--- Deleting existing steps ---")
        write_and_report(inst, "PROG:EDIT:DEL")

        # --- Add placeholder steps ---
        step_count = len(STEPS)
        print(f"\n--- Adding {step_count} placeholder steps ---")
        write_and_report(inst, f"PROG:EDIT:ADD {step_count}")

        # Confirm count from instrument
        cnt = inst.query("PROG:EDIT:COUN?").strip()
        print("Device reports step count =", cnt)

        # --- Write each step ---
        print("\n--- Writing step values ---")
        for s in STEPS:
            n = s["step"]
            v = s["volt"]
            t = s["time"]

            print(f"\nWriting Step {n}: V={v}, T={t}")

            # 1) Select step n
            write_and_report(inst, f"PROG:EDIT:STEP:SEL {n}")

            # 2) Set DC voltage level (IMMediate by default)
            write_and_report(inst, f"PROG:EDIT:STEP:VOLT {v}")

            # 3) Set step time
            write_and_report(inst, f"PROG:EDIT:STEP:TIME {t}")

            # 4) Ensure output is ON in this step, no trig out/in
            #    STATe {OUT_ON},{TRIG_OUT},{TRIG_IN}
            write_and_report(inst, "PROG:EDIT:STEP:STAT ON,OFF,OFF")

        # --- Done programming ---
        print("\nProgramming finished.")

        # If you want to *run* the program automatically, uncomment this block:
        """
        print("\n--- Starting program execution ---")
        write_and_report(inst, "TRIG:PROG:SOUR IMM")   # run immediately when told
        write_and_report(inst, "OUTP ON")              # turn output ON
        write_and_report(inst, "PROG:EXEC:STAT RUN")   # start program
        """

    finally:
        try:
            inst.close()
        except:
            pass
        print("\nConnection closed.")

if __name__ == "__main__":
    main()
