import pyvisa
import time

TARGET_RESOURCE = "USB0::0x0B3E::0x1012::EZ002642::INSTR"

# Example program/steps
PROGRAM_SLOT = "1"
PROGRAM_TITLE = "ACC_D1_TEST"
LOOP_COUNT = 1
CURRENT_LIMIT_A = 5.0
NEW_STEPS = [
    {"step": 1, "volt": 0.0,  "time": 1.0},
    {"step": 2, "volt": 12.0, "time": 0.1},
    {"step": 3, "volt": 0.0,  "time": 1.0},
]

def scpi_err(inst, context=""):
    """Query SYST:ERR? and raise a RuntimeError with the text (for visibility)."""
    try:
        e = inst.query("SYST:ERR?").strip()
    except Exception as ex:
        raise RuntimeError(f"{context}: failed to query SYST:ERR? -> {ex}")
    if e and ("no error" not in e.lower() and not e.startswith("0,")):
        # Return the error string for printing without raising immediately
        return e
    return None

def try_resize(inst, n):
    """
    Try a list of candidate resize commands. Return True if any succeeded.
    Also returns the last SYST:ERR? text (if any).
    """
    # Candidate commands observed across PBZ/variants â€” we will try them in order.
    candidates = [
        f":PROG:STEP:COUN {int(n)}",
        f":PROG:EDIT:STEP:COUN {int(n)}",
        f":PROG:STEP:COUNT {int(n)}",      # sometimes spelled COUNT
        f":PROG:EDIT:STEP:COUNT {int(n)}",
        f":PROG:EDIT:COUN {int(n)}",
    ]
    last_err = None
    for cmd in candidates:
        try:
            inst.write(cmd)
            time.sleep(0.05)
            last_err = scpi_err(inst, f"after write {cmd}")
            if last_err is None:
                # verify by attempting to read back count (try several queries)
                for q in (":PROG:STEP:COUN?", ":PROG:EDIT:STEP:COUN?", ":PROG:STEP:COUNT?", ":PROG:EDIT:STEP:COUNT?", ":PROG:EDIT:COUN?"):
                    try:
                        resp = inst.query(q).strip()
                        if resp:
                            # many devices reply like "3" or "3,OK" or "3\r\n"
                            try:
                                cnt = int(resp.split(",")[0])
                                if cnt >= n:
                                    return True, None
                            except Exception:
                                # not integer parseable; continue trying other queries
                                pass
                    except Exception:
                        pass
                # if no query returned a count but SYST:ERR? is clear, treat as success
                return True, None
            else:
                print(f"Resize attempt '{cmd}' returned error: {last_err}")
        except Exception as ex:
            last_err = f"EXCEPTION writing {cmd}: {ex}"
            print(last_err)
    return False, last_err

def write_step_using_edit_fields(inst, step_idx, volt, curr, t):
    """
    Select the step then write VOLT/CURR/TIME. Use the standard edit-field commands.
    """
    inst.write(f"PROG:EDIT:STEP:SEL {int(step_idx)}")
    ee = scpi_err(inst, f"after SEL {step_idx}")
    if ee: raise RuntimeError(f"SEL {step_idx} failed -> {ee}")

    inst.write(f"PROG:EDIT:STEP:VOLT {float(volt)}")
    ee = scpi_err(inst, f"after VOLT {step_idx}")
    if ee: raise RuntimeError(f"VOLT {step_idx} failed -> {ee}")

    inst.write(f"PROG:EDIT:STEP:CURR {float(curr)}")
    ee = scpi_err(inst, f"after CURR {step_idx}")
    if ee: raise RuntimeError(f"CURR {step_idx} failed -> {ee}")

    inst.write(f"PROG:EDIT:STEP:TIME {float(t)}")
    ee = scpi_err(inst, f"after TIME {step_idx}")
    if ee: raise RuntimeError(f"TIME {step_idx} failed -> {ee}")

def upload_program(inst, slot, title, loops, steps, current_limit):
    # select program
    inst.write("*CLS")
    inst.write("ABORT")
    inst.write("SYST:REM")
    time.sleep(0.05)
    inst.write(f':PROG:NAME "{slot}"')
    e = scpi_err(inst, "select program")
    if e: print("select program SYST:ERR? ->", e)

    inst.write(f':PROG:EDIT:TITL "{title}"')
    inst.write(f":PROG:EDIT:LOOP {int(loops)}")
    e = scpi_err(inst, "set title/loop")
    if e: print("title/loop SYST:ERR? ->", e)

    # Attempt to set step count to the number we need
    desired = len(steps)
    ok, last_err = try_resize(inst, desired)
    if not ok:
        raise RuntimeError(f"Failed to resize to {desired} steps. Last error: {last_err}")

    # verify actual count by trying queries
    count = None
    for q in (":PROG:STEP:COUN?", ":PROG:EDIT:STEP:COUN?", ":PROG:STEP:COUNT?", ":PROG:EDIT:STEP:COUNT?"):
        try:
            resp = inst.query(q).strip()
            if resp:
                try:
                    count = int(resp.split(",")[0])
                    break
                except Exception:
                    pass
        except Exception:
            pass
    print("Verified step count (queried) =", count)

    if count is not None and count < desired:
        raise RuntimeError(f"After resize, device reports only {count} steps (< {desired}).")

    # Now write each step's fields
    for s in sorted(steps, key=lambda x: x["step"]):
        print(f"Writing step {s['step']} => V={s['volt']} V, I={current_limit} A, T={s['time']} s")
        try:
            write_step_using_edit_fields(inst, s['step'], s['volt'], current_limit, s['time'])
        except RuntimeError as re:
            # Print SYST:ERR? and re-raise to show raw instrument text
            print("Error text from instrument:", scpi_err(inst, f"after failing step {s['step']}"))
            raise

    # Save
    inst.write(":PROG:SAVE")
    time.sleep(0.2)
    print("Saved. SYST:ERR? ->", scpi_err(inst, "after save"))

def main():
    rm = pyvisa.ResourceManager()
    inst = rm.open_resource(TARGET_RESOURCE)
    inst.read_termination = "\n"
    inst.write_termination = "\n"
    inst.timeout = 5000

    try:
        print("IDN:", inst.query("*IDN?").strip())
        upload_program(inst, PROGRAM_SLOT, PROGRAM_TITLE, LOOP_COUNT, NEW_STEPS, CURRENT_LIMIT_A)
    except Exception as e:
        print("FAILED:", e)
    finally:
        try:
            inst.close()
        except:
            pass

if __name__ == "__main__":
    main()
