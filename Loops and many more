# robust_step_upload.py
import pyvisa
import time

TARGET_RESOURCE = "USB0::0x0B3E::0x1012::EZ002642::INSTR"

PROGRAM_SLOT = "1"
PROGRAM_TITLE = "ACC_D1_TEST"
LOOP_COUNT = 1
CURRENT_LIMIT_A = 5.0

NEW_STEPS = [
    {"step": 1, "volt": 0.0,  "time": 1.0},
    {"step": 2, "volt": 12.0, "time": 0.1},
    {"step": 3, "volt": 0.0,  "time": 1.0},
    {"step": 4, "volt": 13.0, "time": 20.0},
    {"step": 5, "volt": 0.0,  "time": 2.0},
]

# candidate commands to create/insert steps (we try them if selection fails)
INSERT_CANDIDATES = [
    ":PROG:EDIT:STEP:INS {n}",    # insert step n
    ":PROG:STEP:INS {n}",
    ":PROG:STEP:NEW {n}",        # create new step n
    ":PROG:EDIT:STEP:NEW {n}",
    ":PROG:EDIT:STEP:CRE {n}",
    ":PROG:STEP:CRE {n}",
]

def read_err(inst, ctx=""):
    """Query SYST:ERR? and return the raw string (or None if no error)."""
    try:
        resp = inst.query("SYST:ERR?").strip()
    except Exception as e:
        return f"EXC querying SYST:ERR? after {ctx}: {e}"
    if resp == "" or "no error" in resp.lower() or resp.startswith("0,"):
        return None
    return resp

def try_select_step(inst, n):
    """Try to select step n. Return None on success, or the SYST:ERR? text on failure."""
    inst.write(f"PROG:EDIT:STEP:SEL {int(n)}")
    time.sleep(0.05)
    return read_err(inst, f"SEL {n}")

def try_insert_step(inst, n):
    """Try each insertion candidate for index n. Return tuple(success_bool, last_err_text)."""
    last_err = None
    for template in INSERT_CANDIDATES:
        cmd = template.format(n=int(n))
        try:
            inst.write(cmd)
            time.sleep(0.08)
        except Exception as e:
            last_err = f"EXC writing {cmd}: {e}"
            print(last_err)
            continue
        last_err = read_err(inst, f"after '{cmd}'")
        print(f"Attempted '{cmd}' -> SYST:ERR? = {last_err}")
        # if instrument returns no error, treat as success
        if last_err is None:
            # confirm by trying select
            sel_err = try_select_step(inst, n)
            if sel_err is None:
                return True, None
            else:
                # selection still fails; continue trying other insert commands
                print(f"Insert command succeeded but selection still fails: {sel_err}")
    return False, last_err

def write_step_fields(inst, n, volt, curr, t):
    """Write the VOLT, CURR and TIME fields for selected step n."""
    inst.write(f"PROG:EDIT:STEP:VOLT {float(volt)}")
    e = read_err(inst, f"VOLT {n}")
    if e: raise RuntimeError(f"VOLT failed for step {n} -> {e}")

    inst.write(f"PROG:EDIT:STEP:CURR {float(curr)}")
    e = read_err(inst, f"CURR {n}")
    if e: raise RuntimeError(f"CURR failed for step {n} -> {e}")

    inst.write(f"PROG:EDIT:STEP:TIME {float(t)}")
    e = read_err(inst, f"TIME {n}")
    if e: raise RuntimeError(f"TIME failed for step {n} -> {e}")

def upload_sequence(resource, slot, title, loops, steps, curr_limit):
    rm = pyvisa.ResourceManager()
    inst = rm.open_resource(resource)
    inst.read_termination = "\n"
    inst.write_termination = "\n"
    inst.timeout = 8000

    try:
        print("IDN:", inst.query("*IDN?").strip())

        # basic program header
        inst.write("*CLS")
        inst.write("ABORT")
        inst.write("SYST:REM")
        time.sleep(0.1)
        inst.write(f':PROG:NAME "{slot}"')
        time.sleep(0.05)
        inst.write(f':PROG:EDIT:TITL "{title}"')
        inst.write(f":PROG:EDIT:LOOP {int(loops)}")
        time.sleep(0.05)
        print("Header set. SYST:ERR? ->", read_err(inst, "after header"))

        # For each step: try select -> if fail, try inserting -> then write fields
        for s in sorted(steps, key=lambda x: x["step"]):
            n = s["step"]
            print(f"\n--- Handling step {n} ---")
            sel_err = try_select_step(inst, n)
            if sel_err is None:
                print(f"Step {n} selectable (already exists).")
            else:
                print(f"Selecting step {n} returned error: {sel_err}")
                print("Trying insert/create candidates...")
                ok, last_err = try_insert_step(inst, n)
                if not ok:
                    # show last instrument error and abort
                    raise RuntimeError(f"Failed to create step {n}. Last SYST:ERR? -> {last_err}")

            # now we should be able to set fields
            print(f"Writing fields for step {n}: V={s['volt']} V, I={curr_limit} A, T={s['time']} s")
            # It's necessary to re-select the step before writing fields (some firmwares require it)
            inst.write(f"PROG:EDIT:STEP:SEL {int(n)}")
            time.sleep(0.03)
            e = read_err(inst, f"re-select {n}")
            if e:
                raise RuntimeError(f"Re-select step {n} failed -> {e}")

            write_step_fields(inst, n, s["volt"], curr_limit, s["time"])
            print(f"Step {n} written. SYST:ERR? ->", read_err(inst, f"after writing step {n}"))

        # Save program
        inst.write(":PROG:SAVE")
        time.sleep(0.3)
        print("Saved. SYST:ERR? ->", read_err(inst, "after save"))

        # Optionally run
        inst.write("OUTP 1")
        time.sleep(0.1)
        inst.write(":PROG:EXEC:STAT RUN")
        print("Started. SYST:ERR? ->", read_err(inst, "after start"))

    finally:
        try:
            inst.close()
        except:
            pass
        print("Connection closed.")

if __name__ == "__main__":
    upload_sequence(TARGET_RESOURCE, PROGRAM_SLOT, PROGRAM_TITLE, LOOP_COUNT, NEW_STEPS, CURRENT_LIMIT_A)
