# upload_from_patterns.py
import json, pyvisa, time

PATTERNS_FILE = "patterns.json"
TARGETS_FILE = "targets.json"

# ------------------------------------------------------
# LOOP VALUE MOVED HERE (removed from JSON)
# Change this = it applies to ALL devices
PROGRAM_LOOP_COUNT = 1
# ------------------------------------------------------

PAUSE_SHORT = 0.06
PAUSE_MED = 0.12
VISA_TIMEOUT_MS = 5000

def open_inst(resource):
    rm = pyvisa.ResourceManager()
    inst = rm.open_resource(resource)
    inst.read_termination = "\n"
    inst.write_termination = "\n"
    inst.timeout = VISA_TIMEOUT_MS
    return inst

def syserr(inst, ctx=""):
    try:
        return inst.query("SYST:ERR?").strip()
    except Exception as e:
        return f"EXC SYST:ERR? ({ctx}): {e}"

def write_and_report(inst, cmd, pause=PAUSE_MED):
    try:
        inst.write(cmd)
    except Exception as e:
        print(f"EXC writing '{cmd}': {e}")
        return f"EXC write {e}"
    time.sleep(pause)
    err = syserr(inst, cmd)
    print(f"WROTE '{cmd}' -> {err}")
    return err

def validate_steps(steps):
    steps_sorted = sorted(steps, key=lambda s: s["step"])
    for i, s in enumerate(steps_sorted, start=1):
        if s["step"] != i:
            raise ValueError(f"Steps must be contiguous starting at 1. Found step={s['step']} at index={i}")
    return steps_sorted

def upload_pattern(device_cfg, pattern):
    res = device_cfg["resource"]
    slot = device_cfg["program_slot"]
    run_after = device_cfg.get("run_after_upload", False)

    title = pattern["title"]
    steps = validate_steps(pattern["steps"])
    loop = PROGRAM_LOOP_COUNT   # <-- LOOP COMES FROM SCRIPT ONLY

    print("\n====================================================")
    print(f"Uploading pattern '{title}' to device {res}")
    print("====================================================")

    inst = None
    try:
        inst = open_inst(res)
        print("IDN:", inst.query("*IDN?").strip())
        inst.write("*CLS"); inst.write("ABOR"); inst.write("SYST:REM")

        write_and_report(inst, f'PROG:NAME "{slot}"')
        write_and_report(inst, f'PROG:EDIT:TITL "{title}"')
        write_and_report(inst, f'PROG:EDIT:LOOP {loop}')
        write_and_report(inst, "PROG:EDIT ON")

        # delete and add fresh steps
        write_and_report(inst, "PROG:EDIT:DEL")
        write_and_report(inst, f"PROG:EDIT:ADD {len(steps)}")

        # write steps
        for s in steps:
            n = s["step"]; v = s["volt"]; t = s["time"]
            print(f"\n--- Step {n}: V={v}, T={t} ---")
            write_and_report(inst, f"PROG:EDIT:STEP:SEL {n}")
            write_and_report(inst, f"PROG:EDIT:STEP:VOLT {v}")
            write_and_report(inst, f"PROG:EDIT:STEP:TIME {t}")

        # save
        write_and_report(inst, "PROG:SAVE")

        # run program
        if run_after:
            write_and_report(inst, "OUTP ON")
            write_and_report(inst, "PROG:EXEC:STAT RUN")

        print(f"Upload DONE for {res}")
        return True

    except Exception as e:
        print("Error:", e)
        return False

    finally:
        if inst:
            try: inst.close()
            except: pass

def main():
    patterns = json.load(open(PATTERNS_FILE))
    targets = json.load(open(TARGETS_FILE))

    success = True
    for dev_name, dev_cfg in targets.items():
        pattern_name = dev_cfg["pattern"]

        if pattern_name not in patterns:
            print(f"ERROR: Pattern '{pattern_name}' not defined.")
            success = False
            continue

        ok = upload_pattern(dev_cfg, patterns[pattern_name])
        if not ok:
            success = False
            print(f"Device {dev_name} FAILED.")

    print("\nAll done! Overall:", success)

if __name__ == "__main__":
    main()
