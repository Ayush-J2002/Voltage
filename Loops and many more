# pbz_upload_sequence.py
# Combined script: delete current steps, add placeholders, upload volt/time for each step, save and optionally run.
# Requires pyvisa.

import pyvisa
import time

# ---------- EDIT THESE ----------
RESOURCE = "USB0::0x0B3E::0x1012::EZ002642::INSTR"   # your VISA resource
PROGRAM_SLOT = "1"                                   # program slot to use
RUN_AFTER_SAVE = False                               # set True to auto-run after saving

# Steps to write (step indices should be 1..N contiguous)
STEPS = [
    {"step": 1, "volt": 0.0,  "time": 1.0},
    {"step": 2, "volt": 12.0, "time": 0.1},
    {"step": 3, "volt": 0.0,  "time": 1.0},
    {"step": 4, "volt": 13.0, "time": 20.0},
    {"step": 5, "volt": 0.0,  "time": 2.0},
]
# --------------------------------

# Safety: ensure steps are contiguous and start at 1
def validate_steps(steps):
    if not steps:
        raise ValueError("STEPS is empty")
    steps_sorted = sorted(steps, key=lambda s: s["step"])
    for i, s in enumerate(steps_sorted, start=1):
        if s["step"] != i:
            raise ValueError(f"Step indices must be contiguous starting at 1. Found {s['step']} at position {i}.")
    return steps_sorted

def open_inst(resource, timeout_ms=5000):
    rm = pyvisa.ResourceManager()
    inst = rm.open_resource(resource)
    inst.read_termination = "\n"
    inst.write_termination = "\n"
    inst.timeout = timeout_ms
    return inst

def syserr(inst, ctx=""):
    try:
        return inst.query("SYST:ERR?").strip()
    except Exception as e:
        return f"EXC querying SYST:ERR? after {ctx}: {e}"

def write_and_report(inst, cmd, pause=0.12):
    """Write a command, pause, and print/return SYST:ERR?"""
    try:
        inst.write(cmd)
    except Exception as e:
        print(f"EXC writing '{cmd}': {e}")
        return f"EXC write {e}"
    time.sleep(pause)
    err = syserr(inst, cmd)
    print(f"WROTE '{cmd}' -> {err}")
    return err

def try_write_variants(inst, variants):
    """Try several variant strings until one returns no error (or return last error)."""
    last_err = None
    for v in variants:
        err = write_and_report(inst, v)
        last_err = err
        if isinstance(err, str) and (err.startswith('0,') or 'no error' in err.lower()):
            return True, err
    return False, last_err

def main():
    steps = validate_steps(STEPS)
    step_count = len(steps)
    inst = open_inst(RESOURCE)
    try:
        print("IDN:", inst.query("*IDN?").strip())

        # Basic prep
        for c in ("*CLS", "ABORT", "SYST:REM"):
            try:
                inst.write(c)
                time.sleep(0.05)
            except Exception:
                pass

        # Select program slot
        inst.write(f':PROG:NAME "{PROGRAM_SLOT}"')
        time.sleep(0.08)
        print("After selecting program slot ->", syserr(inst, "select program"))

        # Enter program edit mode if supported (some firmwares accept this)
        _ = write_and_report(inst, "PROG:EDIT ON", pause=0.06)   # harmless if not supported

        # 1) Delete existing steps - try a couple forms
        print("\n--- Deleting existing steps ---")
        delete_variants = [
            ":PROGRAM:EDIT:DEL",      # user-supplied working form
            ":PROG:EDIT:DEL",
            ":PROG:EDIT:STEP:DEL",
            ":PROG:EDIT:DEL ALL",
        ]
        ok, err = try_write_variants(inst, delete_variants)
        if not ok:
            print("Warning: delete attempts did not return 'No error' â€” continuing anyway. Last:", err)

        # 2) Add the required number of placeholder steps
        # Try with a simple single add command that takes a count, or loop inserting
        print("\n--- Adding placeholder steps ---")
        # Try a single ADD <n> variant
        add_variants = [
            f":PROGRAM:EDIT:ADD {step_count}",
            f":PROG:EDIT:ADD {step_count}",
            f":PROG:EDIT:STEP:ADD {step_count}",
            f":PROG:EDIT:STEP:INS {step_count}",
            f":PROG:EDIT:STEP:COUN {step_count}"
        ]
        ok, last = try_write_variants(inst, add_variants)
        if not ok:
            # fallback: add steps one-by-one (try a couple of single-add forms)
            print("Single-add variants failed; trying incremental add/ins forms for each step.")
            single_add_forms = ["PROG:EDIT:STEP:INS", "PROG:EDIT:STEP:ADD", "PROG:STEP:INS", "PROG:STEP:ADD"]
            for i in range(step_count):
                success = False
                for form in single_add_forms:
                    cmd = f"{form} {i+1}" if " " in form else f"{form} {i+1}"
                    err = write_and_report(inst, cmd)
                    if err and (err.startswith("0,") or "no error" in err.lower()):
                        success = True
                        break
                if not success:
                    # one final try: some firmwares accept the form with no index
                    for form in single_add_forms:
                        cmd = f"{form}"
                        err = write_and_report(inst, cmd)
                        if err and (err.startswith("0,") or "no error" in err.lower()):
                            success = True
                            break
                if not success:
                    print(f"WARNING: could not verify add for step {i+1}. Last ERR: {err}")
            # continue anyway

        # After add, check reported step count (best-effort)
        # Try a few query variants
        step_count_reported = None
        for q in (":PROG:EDIT:COUN?", ":PROG:EDIT:COUNT?", ":PROG:EDIT:STEP:COUN?"):
            try:
                resp = inst.query(q).strip()
                if resp:
                    try:
                        step_count_reported = int(resp.split(",")[0])
                        break
                    except Exception:
                        pass
            except Exception:
                pass
        print("Device reports step count =", step_count_reported)

        if step_count_reported is not None and step_count_reported < step_count:
            print(f"WARNING: device reports fewer steps ({step_count_reported}) than requested ({step_count}). Aborting.")
            return

        # 3) Write values to each step (select-then-write pattern)
        print("\n--- Writing step values ---")
        for s in steps:
            n = s["step"]
            v = s["volt"]
            t = s["time"]
            print(f"\nWriting Step {n}: V={v}, T={t}")

            # Select step (this is known-working command)
            err = write_and_report(inst, f"PROG:EDIT:STEP:SEL {n}")
            if not (err.startswith("0,") or "no error" in err.lower()):
                # sometimes the instrument reports 0,"No error" even if syserr printed differently earlier,
                # but if non-zero, still try proceeding, but warn.
                print(f"Warning selecting step {n}: {err}")

            # Write voltage (may return -221 settings conflict for some step types)
            v_err = write_and_report(inst, f"PROG:EDIT:STEP:VOLT {v}")
            if not (v_err.startswith("0,") or "no error" in v_err.lower()):
                print(f"NOTE: VOLT command returned: {v_err} (may indicate settings conflict or disallowed value).")

            # Write time
            t_err = write_and_report(inst, f"PROG:EDIT:STEP:TIME {t}")
            if not (t_err.startswith("0,") or "no error" in t_err.lower()):
                print(f"ERROR writing TIME for step {n}: {t_err}")
                print("Stopping script.")
                return

        # 4) Save program
        print("\n--- Saving program ---")
        save_err = write_and_report(inst, ":PROG:SAVE")
        if not (save_err.startswith("0,") or "no error" in save_err.lower()):
            print("Warning: save returned:", save_err)

        # 5) Optionally run program
        if RUN_AFTER_SAVE:
            print("\n--- Starting program ---")
            write_and_report(inst, "OUTP 1")
            write_and_report(inst, ":PROG:EXEC:STAT RUN")

        print("\nDone.")
    finally:
        try:
            inst.close()
        except Exception:
            pass

if __name__ == "__main__":
    main()
