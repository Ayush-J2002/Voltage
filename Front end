import json
import threading
import tkinter as tk
from tkinter import ttk, messagebox
from pathlib import Path
from copy import deepcopy

import pyvisa

# ---------------- Configuration ---------------- #

SCRIPT_DIR = Path(__file__).resolve().parent
DEFAULT_JSON_PATH = SCRIPT_DIR / "patterns.json"

# VISA targets: fill in your actual USB addresses
TARGETS = {
    "BATTERY": {
        "resource": "USB0::0x0B3E::0x1012::EZ002642::INSTR",
        "program_slot": "1",
    },
    "IGN": {
        "resource": "USB0::0x0B3E::0x1012::EZ002641::INSTR",
        "program_slot": "1",
    },
    "ACC": {
        "resource": "USB0::0x0B3E::0x1012::EZ002640::INSTR",
        "program_slot": "1",
    },
}

PROGRAM_LOOP_COUNT = 1          # program loop count for all channels
VISA_TIMEOUT_MS = 5000
PAUSE_SHORT = 0.06
PAUSE_MED = 0.12

# ---------------- VISA / SCPI helpers ---------------- #

def open_inst(resource: str):
    rm = pyvisa.ResourceManager()
    inst = rm.open_resource(resource)
    inst.read_termination = "\n"
    inst.write_termination = "\n"
    inst.timeout = VISA_TIMEOUT_MS
    return inst

def syserr(inst, ctx=""):
    try:
        return inst.query("SYST:ERR?").strip()
    except Exception as e:
        return f"EXC SYST:ERR? ({ctx}): {e}"

def write_and_report(inst, cmd: str, pause: float = PAUSE_MED):
    try:
        inst.write(cmd)
    except Exception as e:
        print(f"EXC writing '{cmd}': {e}")
        return f"EXC write {e}"
    import time as _time
    _time.sleep(pause)
    err = syserr(inst, cmd)
    print(f"WROTE '{cmd}' -> {err}")
    return err

def validate_steps(steps):
    if not steps:
        raise ValueError("Empty steps list")
    ss = sorted(steps, key=lambda s: s["step"])
    for i, s in enumerate(ss, start=1):
        if s["step"] != i:
            raise ValueError(f"Steps must be 1..N contiguous. Found step={s['step']} at position {i}.")
    return ss

def program_device_for_subpattern(device_name: str, dev_cfg: dict, subpattern: dict, start_now: bool = False):
    """
    Uploads one channel (BATTERY / IGN / ACC) of the selected pattern to one PBZ.
    Handles:
      - DC volt / time
      - optional DC ramp (dc_ramp_start)
      - optional AC sine (ac_amp, ac_freq) with amplitude sweep start=stop=ac_amp

    If start_now is True, it will also OUTP ON + PROG:EXEC:STAT RUN.
    """
    resource = dev_cfg["resource"]
    slot = dev_cfg["program_slot"]
    title = subpattern.get("title", device_name)
    steps = validate_steps(subpattern.get("steps", []))
    loop = PROGRAM_LOOP_COUNT

    print("\n" + "=" * 60)
    print(f"Programming device {device_name} ({resource}), slot {slot}, title '{title}'")
    print("=" * 60)

    inst = None
    try:
        inst = open_inst(resource)
        idn = inst.query("*IDN?").strip()
        print("IDN:", idn)

        # basic prep
        for c in ("*CLS", "ABOR", "SYST:REM"):
            try:
                inst.write(c)
            except Exception:
                pass

        # select program slot and header
        write_and_report(inst, f'PROG:NAME "{slot}"')
        write_and_report(inst, f'PROG:EDIT:TITL "{title}"')
        write_and_report(inst, f'PROG:EDIT:LOOP {int(loop)}')
        write_and_report(inst, "PROG:EDIT ON")

        # delete existing steps and add placeholders
        write_and_report(inst, "PROG:EDIT:DEL")
        write_and_report(inst, f"PROG:EDIT:ADD {len(steps)}")

        # write each step
        for s in steps:
            n = s["step"]
            v = float(s.get("volt", 0.0))
            t = float(s.get("time", 0.0))
            ramp_start = s.get("dc_ramp_start", None)
            ac_amp = s.get("ac_amp", None)
            ac_freq = s.get("ac_freq", None)

            print(f"\nStep {n}: V={v}, T={t}, ramp_start={ramp_start}, ac_amp={ac_amp}, ac_freq={ac_freq}")
            write_and_report(inst, f"PROG:EDIT:STEP:SEL {n}")

            # --- DC / DC RAMP ---
            if ramp_start is not None:
                # DC RAMP: ON, start=ramp_start, stop=v
                write_and_report(inst, f"PROG:EDIT:STEP:VOLT {v},RAMP")
                write_and_report(inst, f"PROG:EDIT:STEP:VOLT:RAMP {float(ramp_start)}")
            else:
                # Simple DC
                write_and_report(inst, f"PROG:EDIT:STEP:VOLT {v}")

            # --- AC / AMPL SWEEP ---
            if ac_amp is not None:
                amp = float(ac_amp)
                write_and_report(inst, "PROG:EDIT:STEP:FUNC SIN")
                write_and_report(inst, "PROG:EDIT:STEP:AC:STAT ON")
                # amplitude sweep start = stop = ac_amp
                write_and_report(inst, f"PROG:EDIT:STEP:VOLT:AC {amp},SWE")
                write_and_report(inst, f"PROG:EDIT:STEP:VOLT:AC:SWE {amp}")
                if ac_freq is not None:
                    write_and_report(inst, f"PROG:EDIT:STEP:FREQ {float(ac_freq)},IMMediate")
            else:
                # AC off for this step
                write_and_report(inst, "PROG:EDIT:STEP:AC:STAT OFF")

            # --- Time ---
            write_and_report(inst, f"PROG:EDIT:STEP:TIME {t}")
            # ensure step status: output on, triggers off
            write_and_report(inst, "PROG:EDIT:STEP:STAT ON,OFF,OFF")

        # save
        write_and_report(inst, "PROG:SAVE")

        # optionally run immediately
        if start_now:
            write_and_report(inst, "OUTP ON")
            write_and_report(inst, "PROG:EXEC:STAT RUN")

        print(f"Device {device_name} programmed (start_now={start_now}).")
        return True

    except Exception as e:
        print(f"EXCEPTION on device {device_name}: {e}")
        return False

    finally:
        if inst is not None:
            try:
                inst.close()
            except Exception:
                pass

def start_all_devices():
    """
    After all devices are programmed, call this to OUTP ON + RUN
    on each device. This makes them start as "simultaneously"
    as our loop allows.
    """
    ok_all = True
    for dev_name, dev_cfg in TARGETS.items():
        resource = dev_cfg["resource"]
        try:
            print(f"Starting device {dev_name} ({resource})...")
            inst = open_inst(resource)
            # we assume program and steps are already saved
            write_and_report(inst, "OUTP ON")
            write_and_report(inst, "PROG:EXEC:STAT RUN")
        except Exception as e:
            print(f"EXCEPTION while starting {dev_name}: {e}")
            ok_all = False
        finally:
            try:
                inst.close()
            except Exception:
                pass
    return ok_all

def run_pattern_on_all_devices(patterns: dict, pattern_name: str):
    """
    1) Programs all devices with the selected pattern but does NOT start them.
    2) When all OK, turns output ON and runs program on all devices.
    """
    if pattern_name not in patterns:
        raise ValueError(f"Pattern '{pattern_name}' not found in JSON.")

    pat = patterns[pattern_name]
    ok_all = True

    # First: program all devices
    for dev_name, dev_cfg in TARGETS.items():
        if dev_name not in pat:
            print(f"WARNING: pattern '{pattern_name}' has no block for device '{dev_name}', skipping.")
            ok_all = False
            continue
        sub = pat[dev_name]
        ok = program_device_for_subpattern(dev_name, dev_cfg, sub, start_now=False)
        if not ok:
            ok_all = False

    if not ok_all:
        print("Not all devices programmed successfully; not starting outputs.")
        return False

    # Second: start all outputs/programs
    ok_start = start_all_devices()
    return ok_start

# ---------------- Tkinter App ---------------- #

class PatternEditorApp(tk.Tk):
    def __init__(self, json_path: Path):
        super().__init__()
        self.title("Power Pattern Editor + Runner")
        self.geometry("820x540")

        self.json_path = json_path
        self.original_patterns = {}
        self.patterns = {}

        self.current_pattern_name = None
        self.current_channel_name = None

        self.pattern_var = tk.StringVar()
        self.channel_var = tk.StringVar()
        self.status_var = tk.StringVar(value="Load patterns.json to begin.")

        # one entry per step: dicts with vars
        self.step_entries = []  # each: {step_no, volt_var, time_var, ramp_var, ac_amp_var, ac_freq_var}

        self._build_ui()
        self._load_patterns()

    # --- UI ---
    def _build_ui(self):
        top = ttk.Frame(self)
        top.pack(fill="x", padx=10, pady=10)

        ttk.Label(top, text="Pattern:").grid(row=0, column=0, sticky="w", padx=(0, 5))
        self.pattern_combo = ttk.Combobox(top, textvariable=self.pattern_var, state="readonly", width=15)
        self.pattern_combo.grid(row=0, column=1, sticky="w")
        self.pattern_combo.bind("<<ComboboxSelected>>", self._on_pattern_change)

        ttk.Label(top, text="Channel:").grid(row=0, column=2, sticky="w", padx=(15, 5))
        self.channel_combo = ttk.Combobox(top, textvariable=self.channel_var, state="readonly", width=15)
        self.channel_combo.grid(row=0, column=3, sticky="w")
        self.channel_combo.bind("<<ComboboxSelected>>", self._on_channel_change)

        btn_frame = ttk.Frame(top)
        btn_frame.grid(row=0, column=4, sticky="e", padx=(20, 0))

        self.reset_btn = ttk.Button(btn_frame, text="Reset Channel", command=self.reset_channel)
        self.reset_btn.grid(row=0, column=0, padx=(0, 5))

        self.save_btn = ttk.Button(btn_frame, text="Save JSON", command=self.save_json)
        self.save_btn.grid(row=0, column=1, padx=(0, 5))

        self.run_btn = ttk.Button(btn_frame, text="Run Pattern", command=self.on_run_clicked)
        self.run_btn.grid(row=0, column=2, padx=(0, 5))

        status_label = ttk.Label(self, textvariable=self.status_var, foreground="#555")
        status_label.pack(fill="x", padx=10)

        steps_frame = ttk.LabelFrame(self, text="Steps")
        steps_frame.pack(fill="both", expand=True, padx=10, pady=10)

        header = ttk.Frame(steps_frame)
        header.pack(fill="x", padx=5, pady=(5, 2))
        ttk.Label(header, text="Step", width=6).grid(row=0, column=0, sticky="w")
        ttk.Label(header, text="Voltage (V)", width=12).grid(row=0, column=1, sticky="w")
        ttk.Label(header, text="Time (s)", width=12).grid(row=0, column=2, sticky="w")
        ttk.Label(header, text="DC Ramp Start (V)", width=16).grid(row=0, column=3, sticky="w")
        ttk.Label(header, text="AC Amp (Vpp)", width=14).grid(row=0, column=4, sticky="w")
        ttk.Label(header, text="AC Freq (Hz)", width=14).grid(row=0, column=5, sticky="w")

        self.steps_canvas = tk.Canvas(steps_frame, borderwidth=0, highlightthickness=0)
        self.steps_inner = ttk.Frame(self.steps_canvas)
        self.scrollbar = ttk.Scrollbar(steps_frame, orient="vertical", command=self.steps_canvas.yview)
        self.steps_canvas.configure(yscrollcommand=self.scrollbar.set)

        self.scrollbar.pack(side="right", fill="y")
        self.steps_canvas.pack(side="left", fill="both", expand=True)
        self.steps_canvas.create_window((0, 0), window=self.steps_inner, anchor="nw")
        self.steps_inner.bind("<Configure>", lambda e: self.steps_canvas.configure(scrollregion=self.steps_canvas.bbox("all")))

    # --- JSON loading/saving ---
    def _load_patterns(self):
        try:
            with open(self.json_path, "r", encoding="utf-8") as f:
                data = json.load(f)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load {self.json_path}:\n{e}")
            self.status_var.set(f"Failed to load JSON: {e}")
            return

        self.original_patterns = deepcopy(data)
        self.patterns = deepcopy(data)

        names = sorted(self.patterns.keys())
        if not names:
            self.status_var.set("patterns.json is empty.")
            return

        self.pattern_combo["values"] = names
        self.pattern_var.set(names[0])
        self.current_pattern_name = names[0]
        self._populate_channel_combo()
        self.status_var.set(f"Loaded {self.json_path.name}. Select pattern and channel.")

    def save_json(self):
        if not self.patterns:
            messagebox.showwarning("Warning", "No patterns to save.")
            return
        ans = messagebox.askyesno("Save JSON", f"Overwrite file:\n{self.json_path}?")
        if not ans:
            return
        try:
            with open(self.json_path, "w", encoding="utf-8") as f:
                json.dump(self.patterns, f, indent=2)
            self.status_var.set(f"Saved changes to {self.json_path}.")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save JSON:\n{e}")
            self.status_var.set(f"Error saving JSON: {e}")

    # --- pattern/channel changes ---
    def _on_pattern_change(self, event=None):
        self.current_pattern_name = self.pattern_var.get()
        self._populate_channel_combo()

    def _populate_channel_combo(self):
        self.step_entries.clear()
        for w in self.steps_inner.winfo_children():
            w.destroy()

        pat = self.patterns.get(self.current_pattern_name, {})
        channels = sorted(pat.keys())
        self.channel_combo["values"] = channels

        if channels:
            self.channel_var.set(channels[0])
            self.current_channel_name = channels[0]
            self._render_steps()
        else:
            self.channel_var.set("")
            self.current_channel_name = None
            self.status_var.set(f"Pattern '{self.current_pattern_name}' has no channels.")

    def _on_channel_change(self, event=None):
        self.current_channel_name = self.channel_var.get()
        self._render_steps()

    # --- steps table ---
    def _render_steps(self):
        self.step_entries.clear()
        for w in self.steps_inner.winfo_children():
            w.destroy()

        if not (self.current_pattern_name and self.current_channel_name):
            return

        chan = self.patterns.get(self.current_pattern_name, {}).get(self.current_channel_name)
        if not chan:
            self.status_var.set(f"No data for channel '{self.current_channel_name}'.")
            return

        steps = chan.get("steps", [])
        for idx, s in enumerate(steps):
            step_no = s.get("step", idx + 1)
            volt = s.get("volt", 0.0)
            time_val = s.get("time", 0.0)

            ramp_start = s.get("dc_ramp_start", None)
            ac_amp = s.get("ac_amp", None)
            ac_freq = s.get("ac_freq", None)

            # Step label
            lbl = ttk.Label(self.steps_inner, text=str(step_no), width=6)
            lbl.grid(row=idx, column=0, sticky="w", padx=5, pady=2)

            # Voltage
            volt_var = tk.StringVar(value=str(volt))
            v_entry = ttk.Entry(self.steps_inner, textvariable=volt_var, width=10)
            v_entry.grid(row=idx, column=1, sticky="w", padx=5, pady=2)

            # Time
            time_var = tk.StringVar(value=str(time_val))
            t_entry = ttk.Entry(self.steps_inner, textvariable=time_var, width=10)
            t_entry.grid(row=idx, column=2, sticky="w", padx=5, pady=2)

            # DC ramp start (only visible if present in JSON)
            if ramp_start is not None:
                ramp_var = tk.StringVar(value=str(ramp_start))
                r_entry = ttk.Entry(self.steps_inner, textvariable=ramp_var, width=14)
                r_entry.grid(row=idx, column=3, sticky="w", padx=5, pady=2)
            else:
                ramp_var = None
                r_label = ttk.Label(self.steps_inner, text="", width=14)
                r_label.grid(row=idx, column=3, sticky="w", padx=5, pady=2)

            # AC amp (only if present)
            if ac_amp is not None:
                ac_amp_var = tk.StringVar(value=str(ac_amp))
                a_entry = ttk.Entry(self.steps_inner, textvariable=ac_amp_var, width=12)
                a_entry.grid(row=idx, column=4, sticky="w", padx=5, pady=2)
            else:
                ac_amp_var = None
                a_label = ttk.Label(self.steps_inner, text="", width=12)
                a_label.grid(row=idx, column=4, sticky="w", padx=5, pady=2)

            # AC freq (only if present)
            if ac_freq is not None:
                ac_freq_var = tk.StringVar(value=str(ac_freq))
                f_entry = ttk.Entry(self.steps_inner, textvariable=ac_freq_var, width=12)
                f_entry.grid(row=idx, column=5, sticky="w", padx=5, pady=2)
            else:
                ac_freq_var = None
                f_label = ttk.Label(self.steps_inner, text="", width=12)
                f_label.grid(row=idx, column=5, sticky="w", padx=5, pady=2)

            entry_info = {
                "step_no": step_no,
                "volt_var": volt_var,
                "time_var": time_var,
                "ramp_var": ramp_var,
                "ac_amp_var": ac_amp_var,
                "ac_freq_var": ac_freq_var,
            }
            self.step_entries.append(entry_info)

            # traces for live updates
            volt_var.trace_add("write", self._on_step_edited)
            time_var.trace_add("write", self._on_step_edited)
            if ramp_var is not None:
                ramp_var.trace_add("write", self._on_step_edited)
            if ac_amp_var is not None:
                ac_amp_var.trace_add("write", self._on_step_edited)
            if ac_freq_var is not None:
                ac_freq_var.trace_add("write", self._on_step_edited)

        self._sync_entries_to_data()
        self.status_var.set(f"Editing pattern '{self.current_pattern_name}', channel '{self.current_channel_name}'.")

    def _on_step_edited(self, *args):
        self._sync_entries_to_data()

    def _sync_entries_to_data(self):
        if not (self.current_pattern_name and self.current_channel_name):
            return
        chan = self.patterns[self.current_pattern_name][self.current_channel_name]
        steps = chan.setdefault("steps", [])

        if len(steps) < len(self.step_entries):
            for _ in range(len(self.step_entries) - len(steps)):
                steps.append({"step": 0, "volt": 0.0, "time": 0.0})

        for idx, info in enumerate(self.step_entries):
            s = steps[idx]
            s["step"] = info["step_no"]

            # Voltage
            try:
                s["volt"] = float(info["volt_var"].get())
            except ValueError:
                s["volt"] = 0.0

            # Time
            try:
                s["time"] = float(info["time_var"].get())
            except ValueError:
                s["time"] = 0.0

            # Optional DC ramp start
            if info["ramp_var"] is not None:
                try:
                    s["dc_ramp_start"] = float(info["ramp_var"].get())
                except ValueError:
                    s["dc_ramp_start"] = 0.0
            else:
                # if it wasn't in JSON originally, don't add it
                if "dc_ramp_start" in s and s["dc_ramp_start"] is None:
                    del s["dc_ramp_start"]

            # Optional AC amp
            if info["ac_amp_var"] is not None:
                try:
                    s["ac_amp"] = float(info["ac_amp_var"].get())
                except ValueError:
                    s["ac_amp"] = 0.0
            else:
                if "ac_amp" in s and s["ac_amp"] is None:
                    del s["ac_amp"]

            # Optional AC freq
            if info["ac_freq_var"] is not None:
                try:
                    s["ac_freq"] = float(info["ac_freq_var"].get())
                except ValueError:
                    s["ac_freq"] = 0.0
            else:
                if "ac_freq" in s and s["ac_freq"] is None:
                    del s["ac_freq"]

    # --- reset + run ---
    def reset_channel(self):
        if not (self.current_pattern_name and self.curren
