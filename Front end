import json
import threading
import tkinter as tk
from tkinter import ttk, messagebox
from pathlib import Path
from copy import deepcopy

import pyvisa

# ============================================================
# Configuration
# ============================================================

SCRIPT_DIR = Path(__file__).resolve().parent
DEFAULT_JSON_PATH = SCRIPT_DIR / "patterns.json"

TARGETS = {
    "BATTERY": {
        "resource": "USB0::0x0B3E::0x1012::EZ002642::INSTR",
        "program_slot": "1",
    },
    "IGN": {
        "resource": "USB0::0x0B3E::0x1012::EZ002641::INSTR",
        "program_slot": "1",
    },
    "ACC": {
        "resource": "USB0::0x0B3E::0x1012::EZ002640::INSTR",
        "program_slot": "1",
    },
}

VISA_TIMEOUT_MS = 5000
PAUSE_SHORT = 0.06
PAUSE_MED = 0.12

# ============================================================
# VISA helpers
# ============================================================

def open_inst(resource):
    rm = pyvisa.ResourceManager()
    inst = rm.open_resource(resource)
    inst.read_termination = "\n"
    inst.write_termination = "\n"
    inst.timeout = VISA_TIMEOUT_MS
    return inst


def write_and_report(inst, cmd, pause=PAUSE_MED):
    try:
        inst.write(cmd)
        import time; time.sleep(pause)
        err = inst.query("SYST:ERR?")
        print(f"WROTE '{cmd}' -> {err}")
        return err
    except Exception as e:
        print(f"EXC '{cmd}': {e}")
        return None


def validate_steps(steps):
    steps = sorted(steps, key=lambda s: s["step"])
    for i, s in enumerate(steps, start=1):
        if s["step"] != i:
            raise ValueError("Steps must be sequential")
    return steps


# ============================================================
# Programming logic
# ============================================================

def program_device_for_subpattern(device_name, dev_cfg, subpattern, loop_count):
    inst = open_inst(dev_cfg["resource"])

    steps = validate_steps(subpattern["steps"])
    write_and_report(inst, f'PROG:NAME "{dev_cfg["program_slot"]}"')
    write_and_report(inst, f'PROG:EDIT:TITL "{device_name}"')
    write_and_report(inst, f"PROG:EDIT:LOOP {loop_count}")
    write_and_report(inst, "PROG:EDIT ON")
    write_and_report(inst, "PROG:EDIT:DEL")
    write_and_report(inst, f"PROG:EDIT:ADD {len(steps)}")

    for s in steps:
        write_and_report(inst, f"PROG:EDIT:STEP:SEL {s['step']}")
        write_and_report(inst, f"PROG:EDIT:STEP:VOLT {s['volt']}")
        write_and_report(inst, f"PROG:EDIT:STEP:TIME {s['time']}")

        if "dc_ramp_start" in s:
            write_and_report(inst, "PROG:EDIT:STEP:VOLT:RAMP ON")
            write_and_report(inst, f"PROG:EDIT:STEP:VOLT:RAMP {s['dc_ramp_start']}")

        if "ac_amp" in s:
            wave = s.get("ac_wave", "SIN")
            write_and_report(inst, f"PROG:EDIT:STEP:FUNC {wave}")
            write_and_report(inst, "PROG:EDIT:STEP:AC:STAT ON")
            write_and_report(inst, f"PROG:EDIT:STEP:VOLT:AC {s['ac_amp']}")
            write_and_report(inst, f"PROG:EDIT:STEP:FREQ {s['ac_freq']}")

    write_and_report(inst, "PROG:SAVE")
    inst.close()


def start_all_devices():
    threads = []

    def start(dev):
        inst = open_inst(TARGETS[dev]["resource"])
        write_and_report(inst, "OUTP ON", PAUSE_SHORT)
        write_and_report(inst, "PROG:EXEC:STAT RUN", PAUSE_SHORT)
        inst.close()

    for dev in TARGETS:
        t = threading.Thread(target=start, args=(dev,))
        threads.append(t)
        t.start()

    for t in threads:
        t.join()


def run_pattern_on_all_devices(patterns, name, loop_count):
    for dev in TARGETS:
        program_device_for_subpattern(
            dev, TARGETS[dev], patterns[name][dev], loop_count
        )
    start_all_devices()


# ============================================================
# Tkinter UI
# ============================================================

class PatternEditorApp(tk.Tk):
    def __init__(self, json_path):
        super().__init__()
        self.title("Power Pattern Editor + Runner")
        self.geometry("1050x600")

        self.loop_var = tk.StringVar(value="1")

        self.json_path = json_path
        self.patterns = json.load(open(json_path))
        self.current_pattern = None

        self._build_ui()

    def _build_ui(self):
        top = tk.Frame(self, pady=8)
        top.pack(fill="x")

        tk.Label(top, text="Pattern").grid(row=0, column=0, padx=5)
        self.pattern_cb = ttk.Combobox(
            top, values=list(self.patterns.keys()), state="readonly", width=20
        )
        self.pattern_cb.grid(row=0, column=1, padx=5)
        self.pattern_cb.bind("<<ComboboxSelected>>", self.load_pattern)

        tk.Label(top, text="Loop").grid(row=0, column=2, padx=5)
        tk.Entry(top, textvariable=self.loop_var, width=6).grid(row=0, column=3)

        tk.Button(
            top, text="â–¶ Run Pattern", bg="green", fg="white",
            command=self.run_pattern
        ).grid(row=0, column=4, padx=20)

        # Step table header
        self.table = tk.Frame(self)
        self.table.pack(padx=10, pady=10)

        headers = [
            ("Step", 6),
            ("Voltage (V)", 14),
            ("Time (s)", 14),
            ("DC Ramp Start (V)", 18),
            ("AC Amp (Vpp)", 16),
            ("AC Freq (Hz)", 16),
        ]

        for c, (txt, w) in enumerate(headers):
            tk.Label(self.table, text=txt, width=w, font=("Segoe UI", 9, "bold")).grid(row=0, column=c)

    def load_pattern(self, _):
        for w in self.table.grid_slaves():
            if int(w.grid_info()["row"]) > 0:
                w.destroy()

        self.current_pattern = self.patterns[self.pattern_cb.get()]
        steps = self.current_pattern["BATTERY"]["steps"]

        for r, s in enumerate(steps, start=1):
            tk.Label(self.table, text=s["step"], width=6).grid(row=r, column=0)
            tk.Entry(self.table, width=14).insert(0, s["volt"])
            tk.Entry(self.table, width=14).insert(0, s["time"])

    def run_pattern(self):
        try:
            loop = int(self.loop_var.get())
        except ValueError:
            messagebox.showerror("Error", "Invalid loop value")
            return

        threading.Thread(
            target=run_pattern_on_all_devices,
            args=(self.patterns, self.pattern_cb.get(), loop),
            daemon=True,
        ).start()

        messagebox.showinfo("Running", "Pattern programmed and running on all devices")


# ============================================================
# Main
# ============================================================

if __name__ == "__main__":
    app = PatternEditorApp(DEFAULT_JSON_PATH)
    app.mainloop()
