import json
import threading
import tkinter as tk
from tkinter import ttk, messagebox
from pathlib import Path
from copy import deepcopy

import pyvisa

# ============================================================
# Configuration

SCRIPT_DIR = Path(__file__).resolve().parent
DEFAULT_JSON_PATH = SCRIPT_DIR / "patterns.json"

TARGETS = {
    "BATTERY": {
        "resource": "USB0::0x0B3E::0x1012::EZ002642::INSTR",
        "program_slot": "1",
    },
    "IGN": {
        "resource": "USB0::0x0B3E::0x1012::EZ002641::INSTR",
        "program_slot": "1",
    },
    "ACC": {
        "resource": "USB0::0x0B3E::0x1012::EZ002640::INSTR",
        "program_slot": "1",
    },
}
PROGRAM_LOOP_COUNT=1
VISA_TIMEOUT_MS = 5000
PAUSE_SHORT = 0.06
PAUSE_MED = 0.12


# ============================================================
# VISA / SCPI helpers

def open_inst(resource: str):
    rm = pyvisa.ResourceManager()
    inst = rm.open_resource(resource)
    inst.read_termination = "\n"
    inst.write_termination = "\n"
    inst.timeout = VISA_TIMEOUT_MS
    return inst


def syserr(inst, ctx=""):
    try:
        return inst.query("SYST:ERR?").strip()
    except Exception as e:
        return f"EXC SYST:ERR? ({ctx}): {e}"


def write_and_report(inst, cmd: str, pause: float = PAUSE_MED):
    try:
        inst.write(cmd)
    except Exception as e:
        print(f"EXC writing '{cmd}': {e}")
        return f"EXC write {e}"
    import time as _time
    _time.sleep(pause)
    err = syserr(inst, cmd)
    print(f"WROTE '{cmd}' -> {err}")
    return err


def validate_steps(steps):
    if not steps:
        raise ValueError("Empty steps list")
    ss = sorted(steps, key=lambda s: s["step"])
    for i, s in enumerate(ss, start=1):
        if s["step"] != i:
            raise ValueError(f"Steps must be 1..N contiguous. Found step={s['step']} at position {i}.")
    return ss


def program_device_for_subpattern(device_name: str, dev_cfg: dict, subpattern: dict, loop_count):
    """
    Uploads one channel (BATTERY / IGN / ACC) of the selected pattern to one PBZ.
    Handles:
      - DC volt / time
      - optional DC ramp (dc_ramp_start)
      - optional AC signal (ac_amp, ac_freq, ac_wave)
    Does NOT start the program; starting is done later for all devices together.
    """
    resource = dev_cfg["resource"]
    slot = dev_cfg["program_slot"]
    title = subpattern.get("title", device_name)
    steps = validate_steps(subpattern.get("steps", []))
    loop = loop_count

    print("\n" + "=" * 60)
    print(f"Programming device {device_name} ({resource}), slot {slot}, title '{title}'")
    print("=" * 60)

    inst = None
    try:
        inst = open_inst(resource)
        idn = inst.query("*IDN?").strip()
        print("IDN:", idn)

        # basic prep
        for c in ("*CLS", "ABOR", "SYST:REM"):
            try:
                inst.write(c)
            except Exception:
                pass

        # select program slot and header
        write_and_report(inst, f'PROG:NAME "{slot}"')
        write_and_report(inst, f'PROG:EDIT:TITL "{title}"')
        write_and_report(inst, f'PROG:EDIT:LOOP {int(loop)}')
        write_and_report(inst, "PROG:EDIT ON")

        # delete existing steps and add placeholders
        write_and_report(inst, "PROG:EDIT:DEL")
        write_and_report(inst, f"PROG:EDIT:ADD {len(steps)}")

        # write each step
        for s in steps:
            n = s["step"]
            v = float(s.get("volt", 0.0))
            t = float(s.get("time", 0.0))
            ramp_start = s.get("dc_ramp_start", None)
            ac_amp = s.get("ac_amp", None)
            ac_freq = s.get("ac_freq", None)
            ac_wave = s.get("ac_wave", "SIN")  # supports SIN / SQU / etc.

            print(f"\nStep {n}: V={v}, T={t}, ramp_start={ramp_start}, "
                  f"ac_amp={ac_amp}, ac_freq={ac_freq}, ac_wave={ac_wave}")
            write_and_report(inst, f"PROG:EDIT:STEP:SEL {n}")

            # --- DC / DC RAMP ---
            if ramp_start is not None:
                # DC RAMP: ON, start=ramp_start, stop=v
                write_and_report(inst, f"PROG:EDIT:STEP:VOLT {v},RAMP")
                write_and_report(inst, f"PROG:EDIT:STEP:VOLT:RAMP {float(ramp_start)}")
            else:
                # Simple DC
                write_and_report(inst, f"PROG:EDIT:STEP:VOLT {v}")

            # --- AC / AMPL SWEEP ---
            if ac_amp is not None:
                amp = float(ac_amp)
                wave = str(ac_wave).upper() if ac_wave else "SIN"
                write_and_report(inst, f"PROG:EDIT:STEP:FUNC {wave}")
                write_and_report(inst, "PROG:EDIT:STEP:AC:STAT ON")
                # amplitude sweep start = stop = ac_amp
                write_and_report(inst, f"PROG:EDIT:STEP:VOLT:AC {amp},SWE")
                write_and_report(inst, f"PROG:EDIT:STEP:VOLT:AC:SWE {amp}")
                if ac_freq is not None:
                    write_and_report(inst, f"PROG:EDIT:STEP:FREQ {float(ac_freq)},IMMediate")
            else:
                # AC off for this step
                write_and_report(inst, "PROG:EDIT:STEP:AC:STAT OFF")

            # --- Time ---
            write_and_report(inst, f"PROG:EDIT:STEP:TIME {t}")
            # ensure step status: output on, triggers off
            write_and_report(inst, "PROG:EDIT:STEP:STAT ON,OFF,OFF")

        # save
        write_and_report(inst, "PROG:SAVE")

        print(f"Device {device_name} programmed.")
        return True

    except Exception as e:
        print(f"EXCEPTION on device {device_name}: {e}")
        return False

    finally:
        if inst is not None:
            try:
                inst.close()
            except Exception:
                pass


def start_one_device(dev_name: str, dev_cfg: dict, results: dict):
    """
    Thread worker: open device, OUTP ON, PROG:EXEC:STAT RUN.
    """
    resource = dev_cfg["resource"]
    inst = None
    try:
        print(f"Starting device {dev_name} ({resource})...")
        inst = open_inst(resource)
        write_and_report(inst, "OUTP ON", pause=PAUSE_SHORT)
        write_and_report(inst, "PROG:EXEC:STAT RUN", pause=PAUSE_SHORT)
        results[dev_name] = True
    except Exception as e:
        print(f"EXCEPTION while starting {dev_name}: {e}")
        results[dev_name] = False
    finally:
        if inst is not None:
            try:
                inst.close()
            except Exception:
                pass


def start_all_devices_parallel():
    """
    Starts all devices in parallel threads (OUTP ON + RUN).
    """
    threads = []
    results = {}

    for dev_name, dev_cfg in TARGETS.items():
        t = threading.Thread(target=start_one_device, args=(dev_name, dev_cfg, results), daemon=True)
        threads.append(t)
        t.start()

    for t in threads:
        t.join()

    return all(results.get(dev_name, False) for dev_name in TARGETS.keys())
    


def run_pattern_on_all_devices(patterns: dict, pattern_name: str, loop_count: int):
    """
    1) Programs all devices with the selected pattern but does NOT start them.
    2) When all OK, turns output ON and runs program on all devices in parallel.
    """
    if pattern_name not in patterns:
        raise ValueError(f"Pattern '{pattern_name}' not found in JSON.")

    pat = patterns[pattern_name]
    ok_all = True

    # First: program all devices
    for dev_name, dev_cfg in TARGETS.items():
        if dev_name not in pat:
            print(f"WARNING: pattern '{pattern_name}' has no block for device '{dev_name}', skipping.")
            ok_all = False
            continue
        sub = pat[dev_name]
        ok = program_device_for_subpattern(dev_name, dev_cfg, sub, loop_count)
        if not ok:
            ok_all = False

    if not ok_all:
        print("Not all devices programmed successfully; not starting outputs.")
        return False

    # Second: start all outputs/programs in PARALLEL
    ok_start = start_all_devices_parallel()
    return ok_start

def stop_all_devices(self):
    for dev_name,dev_cfg in TARGETS.items():
        try:
            inst=open_inst(dev_cfg["resource"])
            write_and_report(inst,"ABOR",pause=0.05)
            inst.close()
            print(f"{dev_name} stopped.")
        except Exception as e:
            print(f"Failed to stop {dev_name}: {e}")


# ============================================================
# Tkinter UI

class PatternEditorApp(tk.Tk):
    def __init__(self, json_path: Path):
        super().__init__()
        self.title("Power Pattern Editor + Runner")
        self.geometry("950x580")

        self.json_path = json_path
        self.original_patterns = {}
        self.patterns = {}
        self.loop_var=tk.StringVar(value=str(PROGRAM_LOOP_COUNT))

        self.current_pattern_name = None
        self.current_channel_name = None

        self.pattern_var = tk.StringVar()
        self.channel_var = tk.StringVar()
        self.status_var = tk.StringVar(value="")

        self.step_entries = []  # list of dicts for each step row

        self._build_ui()
        self._load_patterns()
    

    # ---------- UI layout ----------

    def _build_ui(self):
        # Top bar: pattern + Run + toggle editor
        top_frame = tk.Frame(self, bg="#f3f3f3", pady=10)
        top_frame.pack(fill="x")

        tk.Label(top_frame, text="Pattern:", font=("Segoe UI", 11), bg="#f3f3f3").pack(side="left", padx=(10, 5))

        self.pattern_combo = ttk.Combobox(
            top_frame, textvariable=self.pattern_var, state="readonly", width=20
        )
        self.pattern_combo.pack(side="left", padx=(0, 10))
        self.pattern_combo.bind("<<ComboboxSelected>>", self._on_pattern_change)

        #loop
        tk.Label(top_frame, text="Loop:", font=("Segoe UI", 11), bg="#f3f3f3").pack(side="left", padx=(20, 10))
        self.loop_entry=tk.Entry(top_frame,textvariable=self.loop_var,width=6,justify="center")
        self.loop_entry.pack(side="left", padx=(0,20))

        # Toggle editor button
        self.toggle_btn = tk.Button(top_frame, text="Show Editor â–¼", command=self._toggle_editor)
        self.toggle_btn.pack(side="right", padx=(0, 10))

        # Run button
        self.run_btn = tk.Button(
            top_frame,
            text="â–¶ Run Pattern",
            bg="#2e8b57",
            fg="white",
            font=("Segoe UI", 11, "bold"),
            padx=20,
            command=self.on_run_clicked,
        )
        self.run_btn.pack(side="right", padx=(0, 20))

        # Stop button
        self.stop_btn = tk.Button(
            top_frame,
            text="ðŸ›‘ STOP",
            bg="#c0392b",
            fg="white",
            font=("Segoe UI", 11, "bold"),
            padx=20,
            command=self.on_stop_clicked,
        )
        self.stop_btn.pack(side="right", padx=(0, 10))

        # Status bar
        status_frame = tk.Frame(self, bg="#f9f9f9")
        status_frame.pack(fill="x")
        tk.Label(status_frame, textvariable=self.status_var, anchor="w", bg="#f9f9f9").pack(
            fill="x", padx=10, pady=(0, 4)
        )

        # Collapsible editor frame
        self.editor_frame = tk.Frame(self, bd=2, relief="groove")
        # not packed yet â€“ hidden by default

        # Channel + buttons row in editor
        channel_frame = tk.Frame(self.editor_frame, pady=6)
        channel_frame.pack(fill="x", padx=10)

        tk.Label(channel_frame, text="Channel:", font=("Segoe UI", 10)).pack(side="left")
        self.channel_combo = ttk.Combobox(
            channel_frame,
            textvariable=self.channel_var,
            values=[],
            state="readonly",
            width=10,
        )
        self.channel_combo.pack(side="left", padx=(5, 10))
        self.channel_combo.bind("<<ComboboxSelected>>", self._on_channel_change)

        self.reset_btn = tk.Button(channel_frame, text="Reset Channel", command=self.reset_channel)
        self.reset_btn.pack(side="left", padx=5)

        self.save_btn = tk.Button(channel_frame, text="Save JSON", command=self.save_json)
        self.save_btn.pack(side="left", padx=5)

        # Steps header
        steps_frame = tk.Frame(self.editor_frame)
        steps_frame.pack(fill="both", expand=True, padx=10, pady=(4, 8))

        header = tk.Frame(steps_frame)
        header.pack(fill="x")

        headers = [
            ("Step", 6),
            ("Voltage (V)", 12),
            ("Time (s)", 8),
            ("DC Ramp Start (V)", 16),
            ("AC Amp (Vpp)", 16),
            ("AC Freq (Hz)", 16),
        ]
        for col, (text, width) in enumerate(headers):
            tk.Label(header, text=text, font=("Segoe UI", 9, "bold"), width=width, anchor="w").grid(
                row=0, column=col, padx=3, pady=2
            )

        # Scrollable steps table
        self.steps_canvas = tk.Canvas(steps_frame, borderwidth=0, highlightthickness=0)
        self.steps_inner = tk.Frame(self.steps_canvas)
        self.steps_scroll = ttk.Scrollbar(steps_frame, orient="vertical", command=self.steps_canvas.yview)
        self.steps_canvas.configure(yscrollcommand=self.steps_scroll.set)

        self.steps_scroll.pack(side="right", fill="y")
        self.steps_canvas.pack(side="left", fill="both", expand=True)
        self.steps_canvas.create_window((0, 0), window=self.steps_inner, anchor="nw")
        self.steps_inner.bind(
            "<Configure>",
            lambda e: self.steps_canvas.configure(scrollregion=self.steps_canvas.bbox("all")),
        )

    # ---------- Collapsible editor ----------

    def _toggle_editor(self):
        if self.editor_frame.winfo_ismapped():
            self.editor_frame.pack_forget()
            self.toggle_btn.config(text="Show Editor â–¼")
        else:
            self.editor_frame.pack(fill="both", expand=True, padx=10, pady=8)
            self.toggle_btn.config(text="Hide Editor â–²")

    # ---------- JSON load / save ----------

    def _load_patterns(self):
        try:
            with open(self.json_path, "r", encoding="utf-8") as f:
                data = json.load(f)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load {self.json_path}:\n{e}")
            self.status_var.set(f"Failed to load JSON: {e}")
            return

        self.original_patterns = deepcopy(data)
        self.patterns = deepcopy(data)

        names = sorted(self.patterns.keys())
        if not names:
            self.status_var.set("patterns.json is empty.")
            return

        self.pattern_combo["values"] = names
        self.pattern_var.set(names[0])
        self.current_pattern_name = names[0]
        self._populate_channel_combo()
        self.status_var.set("Loaded patterns. Choose pattern and click Run, or show editor to edit steps.")

    def save_json(self):
        # ensure latest edits synced
        self._sync_entries_to_data()

        if not self.patterns:
            messagebox.showwarning("Warning", "No patterns to save.")
            return
        ans = messagebox.askyesno("Save JSON", f"Overwrite file:\n{self.json_path}?")
        if not ans:
            return
        try:
            with open(self.json_path, "w", encoding="utf-8") as f:
                json.dump(self.patterns, f, indent=2)
            self.status_var.set(f"Saved changes to {self.json_path}.")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save JSON:\n{e}")
            self.status_var.set(f"Error saving JSON: {e}")

    # ---------- pattern / channel selection ----------

    def _on_pattern_change(self, event=None):
        self.current_pattern_name = self.pattern_var.get()
        self._populate_channel_combo()

    def _populate_channel_combo(self):
        self.step_entries.clear()
        for w in self.steps_inner.winfo_children():
            w.destroy()

        pat = self.patterns.get(self.current_pattern_name, {})
        channels = sorted(pat.keys())
        self.channel_combo["values"] = channels

        if channels:
            self.channel_var.set(channels[0])
            self.current_channel_name = channels[0]
            self._render_steps()
        else:
            self.channel_var.set("")
            self.current_channel_name = None
            self.status_var.set(f"Pattern '{self.current_pattern_name}' has no channels.")

    def _on_channel_change(self, event=None):
        self.current_channel_name = self.channel_var.get()
        self._render_steps()

    # ---------- steps table rendering ----------

    def _render_steps(self):
        self.step_entries.clear()
        for w in self.steps_inner.winfo_children():
            w.destroy()

        if not (self.current_pattern_name and self.current_channel_name):
            return

        chan = self.patterns.get(self.current_pattern_name, {}).get(self.current_channel_name)
        if not chan:
            self.status_var.set(f"No data for channel '{self.current_channel_name}'.")
            return

        steps = chan.get("steps", [])
        for idx, s in enumerate(steps):
            step_no = s.get("step", idx + 1)
            volt = s.get("volt", 0.0)
            time_val = s.get("time", 0.0)

            ramp_start = s.get("dc_ramp_start", None)
            ac_amp = s.get("ac_amp", None)
            ac_freq = s.get("ac_freq", None)

            # step label
            tk.Label(self.steps_inner, text=str(step_no), width=6, anchor="w").grid(
                row=idx, column=0, padx=3, pady=2
            )

            volt_var = tk.StringVar(value=str(volt))
            time_var = tk.StringVar(value=str(time_val))

            v_entry = tk.Entry(self.steps_inner, textvariable=volt_var, width=12)
            v_entry.grid(row=idx, column=1, padx=3, pady=2, sticky="w")

            t_entry = tk.Entry(self.steps_inner, textvariable=time_var, width=12)
            t_entry.grid(row=idx, column=2, padx=3, pady=2, sticky="w")

            # DC ramp (only if key exists)
            if ramp_start is not None:
                ramp_var = tk.StringVar(value=str(ramp_start))
                r_entry = tk.Entry(self.steps_inner, textvariable=ramp_var, width=16)
                r_entry.grid(row=idx, column=3, padx=3, pady=2, sticky="w")
            else:
                ramp_var = None
                tk.Label(self.steps_inner, text="", width=16).grid(
                    row=idx, column=3, padx=3, pady=2, sticky="w"
                )

            # AC amp
            if ac_amp is not None:
                ac_amp_var = tk.StringVar(value=str(ac_amp))
                a_entry = tk.Entry(self.steps_inner, textvariable=ac_amp_var, width=14)
                a_entry.grid(row=idx, column=4, padx=3, pady=2, sticky="w")
            else:
                ac_amp_var = None
                tk.Label(self.steps_inner, text="", width=14).grid(
                    row=idx, column=4, padx=3, pady=2, sticky="w"
                )

            # AC freq
            if ac_freq is not None:
                ac_freq_var = tk.StringVar(value=str(ac_freq))
                f_entry = tk.Entry(self.steps_inner, textvariable=ac_freq_var, width=14)
                f_entry.grid(row=idx, column=5, padx=3, pady=2, sticky="w")
            else:
                ac_freq_var = None
                tk.Label(self.steps_inner, text="", width=14).grid(
                    row=idx, column=5, padx=3, pady=2, sticky="w"
                )

            info = {
                "step_no": step_no,
                "volt_var": volt_var,
                "time_var": time_var,
                "ramp_var": ramp_var,
                "ac_amp_var": ac_amp_var,
                "ac_freq_var": ac_freq_var,
            }
            self.step_entries.append(info)

            # update on edit
            volt_var.trace_add("write", self._on_step_edited)
            time_var.trace_add("write", self._on_step_edited)
            if ramp_var is not None:
                ramp_var.trace_add("write", self._on_step_edited)
            if ac_amp_var is not None:
                ac_amp_var.trace_add("write", self._on_step_edited)
            if ac_freq_var is not None:
                ac_freq_var.trace_add("write", self._on_step_edited)

        self._sync_entries_to_data()
        self.status_var.set(
            f"Editing pattern '{self.current_pattern_name}', channel '{self.current_channel_name}'."
        )

    def _on_step_edited(self, *args):
        self._sync_entries_to_data()

    def _sync_entries_to_data(self):
        if not (self.current_pattern_name and self.current_channel_name):
            return
        chan = self.patterns[self.current_pattern_name][self.current_channel_name]
        steps = chan.setdefault("steps", [])

        if len(steps) < len(self.step_entries):
            for _ in range(len(self.step_entries) - len(steps)):
                steps.append({"step": 0, "volt": 0.0, "time": 0.0})

        for idx, info in enumerate(self.step_entries):
            s = steps[idx]
            s["step"] = info["step_no"]

            # Voltage
            try:
                s["volt"] = float(info["volt_var"].get())
            except ValueError:
                s["volt"] = 0.0

            # Time
            try:
                s["time"] = float(info["time_var"].get())
            except ValueError:
                s["time"] = 0.0

            # DC ramp: only set if non-empty
            if info["ramp_var"] is not None:
                txt = info["ramp_var"].get().strip()
                if txt != "":
                    try:
                        s["dc_ramp_start"] = float(txt)
                    except ValueError:
                        pass  # leave old value
                else:
                    s.pop("dc_ramp_start", None)

            # AC amp
            if info["ac_amp_var"] is not None:
                txt = info["ac_amp_var"].get().strip()
                if txt != "":
                    try:
                        s["ac_amp"] = float(txt)
                    except ValueError:
                        pass
                else:
                    s.pop("ac_amp", None)

            # AC freq
            if info["ac_freq_var"] is not None:
                txt = info["ac_freq_var"].get().strip()
                if txt != "":
                    try:
                        s["ac_freq"] = float(txt)
                    except ValueError:
                        pass
                else:
                    s.pop("ac_freq", None)

    # ---------- reset & run ----------

    def reset_channel(self):
        if not (self.current_pattern_name and self.current_channel_name):
            return
        ans = messagebox.askyesno(
            "Reset Channel",
            f"Reset channel '{self.current_channel_name}' in pattern '{self.current_pattern_name}' to defaults?",
        )
        if not ans:
            return
        try:
            self.patterns[self.current_pattern_name][self.current_channel_name] = deepcopy(
                self.original_patterns[self.current_pattern_name][self.current_channel_name]
            )
        except KeyError:
            messagebox.showerror("Error", "No original data for this channel.")
            return
        self._render_steps()
        self.status_var.set("Channel reset to defaults.")

    def on_run_clicked(self):
        if not self.current_pattern_name:
            messagebox.showwarning("Run", "No pattern selected.")
            return

        self._sync_entries_to_data()
        pat_name = self.current_pattern_name

        try:
            loop_count = int(self.loop_var.get())
            if loop_count <= 0:
                raise ValueError
        except ValueError:
            messagebox.showerror("Invalid Loop", "Loop count must be a positive integer.")
            return

        self.status_var.set("Programming devices...")
        self.run_btn.config(state="disabled")

        def worker():
            try:
            # Step 1: Program all devices (NO START)
                ok = True
                for dev_name, dev_cfg in TARGETS.items():
                    sub = self.patterns[pat_name].get(dev_name)
                    if not sub:
                        ok = False
                        break
                    if not program_device_for_subpattern(
                        dev_name, dev_cfg, sub, loop_count
                ):
                        ok = False
                        break

                if not ok:
                    self.after(0, lambda: messagebox.showerror(
                        "Error", "Failed to program one or more devices."
                ))
                    return

            # Step 2: Ask user confirmation
                def ask_and_start():
                    ans = messagebox.askyesno(
                    "Ready to Run",
                    "Pattern programmed successfully.\n\nClick YES to start all devices."
                )
                    if ans:
                        self.status_var.set("Starting all devices...")
                        start_all_devices_parallel()
                        self.status_var.set("Pattern running on all devices.")
                    else:
                        self.status_var.set("Run cancelled by user.")

                self.after(0, ask_and_start)

            finally:
                self.after(0, lambda: self.run_btn.config(state="normal"))

        threading.Thread(target=worker, daemon=True).start()

    def on_stop_clicked(self):
        self.status_var.set("Stopping all devices...")
        self.stop_btn.config(state="disabled")
        self.run_btn.config(state="disabled")

        def worker():
            success = True

            for dev_name, dev_cfg in TARGETS.items():
                try:
                    inst = open_inst(dev_cfg["resource"])
                    write_and_report(inst, "OUTP OFF", pause=0.05)
                    write_and_report(inst, "ABOR", pause=0.05)
                    inst.close()
                    print(f"{dev_name} stopped.")
                except Exception as e:
                    print(f"Failed to stop {dev_name}: {e}")
                    success = False

        # UI updates must be on main thread
            def done():
                if success:
                    self.status_var.set("All devices stopped successfully.")
                    messagebox.showinfo("Stopped", "All devices stopped successfully.")
                else:
                    self.status_var.set("Some devices failed to stop.")
                    messagebox.showwarning(
                    "Warning", "Some devices could not be stopped. Check logs."
                )

            self.run_btn.config(state="normal")
            self.stop_btn.config(state="normal")

            self.after(0, done)

        threading.Thread(target=worker, daemon=True).start()

# ============================================================
# Main

if __name__ == "__main__":
    app = PatternEditorApp(DEFAULT_JSON_PATH)
    app.mainloop()
